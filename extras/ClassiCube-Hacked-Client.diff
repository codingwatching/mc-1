commit a435fc9ac7f58e837e5b8f4c15fc8ab55cb5aaa7 (HEAD -> classicube)
Author: Robert de Bath <rdebath@tvisiontech.co.uk>
Date:   Sun Aug 1 20:16:09 2021 +0100

    Bypass server "hack" controls
    
    UserType is forced to OP (adds +ophax on motd)
    Always use +ophax -> Default to allow any block
    Hack packet for noclip and fly.
    Max fog range.
    Block permissions.
    
    Note: This defaults to not installed unless HACKEDCLIENT
    defined as this before the top of the file (ie: Protocol.c)
    
        #define HACKEDCLIENT(x) x
    
    or on the commands line this option is added:
    
        -D'HACKEDCLIENT(x)=x'
    
    Also: Client teleport ("/client tp X Y Z") always available in Chat.c

diff --git a/src/Chat.c b/src/Chat.c
index d5d538416..9b57d1b06 100644
--- a/src/Chat.c
+++ b/src/Chat.c
@@ -637,7 +637,7 @@ static void TeleportCommand_Execute(const cc_string* args, int argsCount) {
 
 static struct ChatCommand TeleportCommand = {
 	"TP", TeleportCommand_Execute,
-	COMMAND_FLAG_SINGLEPLAYER_ONLY,
+	/*COMMAND_FLAG_SINGLEPLAYER_ONLY*/ 0,
 	{
 		"&a/client tp [x y z]",
 		"&eMoves you to the given coordinates.",
diff --git a/src/Protocol.c b/src/Protocol.c
index e93a94f69..80b54fc3f 100644
--- a/src/Protocol.c
+++ b/src/Protocol.c
@@ -30,6 +30,10 @@
 #include "Input.h"
 #include "Utils.h"
 
+#ifndef HACKEDCLIENT
+#define HACKEDCLIENT(x)
+#endif /*HACKEDCLIENT*/
+
 #define QUOTE(x) #x
 #define STRINGIFY(val) QUOTE(val)
 struct _ProtocolData Protocol;
@@ -191,7 +195,9 @@ static void UpdateLocation(EntityID id, struct LocationUpdate* update, cc_bool i
 
 static void UpdateUserType(struct HacksComp* hacks, cc_uint8 value) {
 	cc_bool isOp = value >= 100 && value <= 127;
+	HACKEDCLIENT(isOp = 1);
 	hacks->IsOp  = isOp;
+	HACKEDCLIENT(if(0))
 	if (cpe_blockPerms) return;
 
 	Blocks.CanPlace[BLOCK_BEDROCK]     = isOp;
@@ -200,6 +206,10 @@ static void UpdateUserType(struct HacksComp* hacks, cc_uint8 value) {
 	Blocks.CanPlace[BLOCK_STILL_WATER] = isOp;
 	Blocks.CanPlace[BLOCK_LAVA]        = isOp;
 	Blocks.CanPlace[BLOCK_STILL_LAVA]  = isOp;
+	Blocks.CanDelete[BLOCK_WATER]       = isOp;
+	Blocks.CanDelete[BLOCK_STILL_WATER] = isOp;
+	Blocks.CanDelete[BLOCK_LAVA]        = isOp;
+	Blocks.CanDelete[BLOCK_STILL_LAVA]  = isOp;
 }
 
 
@@ -467,6 +477,9 @@ static void Classic_Handshake(cc_uint8* data) {
 	
 	String_Copy(&hacks->HacksFlags,         &Server.Name);
 	String_AppendString(&hacks->HacksFlags, &Server.MOTD);
+
+	HACKEDCLIENT(String_AppendConst(&hacks->HacksFlags, "+ophax"));
+	HACKEDCLIENT(if(String_ContainsConst(&hacks->HacksFlags, "+ophax")));
 	HacksComp_RecheckFlags(hacks);
 }
 
@@ -700,6 +713,8 @@ static void Classic_Kick(cc_uint8* data) {
 static void Classic_SetPermission(cc_uint8* data) {
 	struct HacksComp* hacks = &LocalPlayer_Instance.Hacks;
 	UpdateUserType(hacks, data[0]);
+
+	HACKEDCLIENT(if(String_ContainsConst(&hacks->HacksFlags, "+ophax")));
 	HacksComp_RecheckFlags(hacks);
 }
 
@@ -1126,6 +1141,11 @@ static void CPE_SetBlockPermission(cc_uint8* data) {
 
 	Blocks.CanPlace[block]  = *data++ != 0;
 	Blocks.CanDelete[block] = *data++ != 0;
+
+	HACKEDCLIENT(
+	    Blocks.CanPlace[block]  |= Blocks.CanPlace[BLOCK_STONE];
+	    Blocks.CanDelete[block] |= Blocks.CanDelete[BLOCK_STONE];
+	);
 	Event_RaiseVoid(&BlockEvents.PermissionsChanged);
 }
 
@@ -1162,6 +1182,8 @@ static void CPE_HackControl(cc_uint8* data) {
 	struct LocalPlayer* p = &LocalPlayer_Instance;
 	int jumpHeight;
 
+	HACKEDCLIENT(return);
+
 	p->Hacks.CanFly            = data[0] != 0;
 	p->Hacks.CanNoclip         = data[1] != 0;
 	p->Hacks.CanSpeed          = data[2] != 0;
@@ -1269,6 +1291,7 @@ static void CPE_SetMapEnvProperty(cc_uint8* data) {
 	case 3:
 		Env_SetCloudsHeight(value); break;
 	case 4:
+		HACKEDCLIENT(return);
 		Math_Clamp(value, -0x7FFF, 0x7FFF);
 		Game_MaxViewDistance = value <= 0 ? DEFAULT_MAX_VIEWDIST : value;
 		Game_SetViewDistance(Game_UserViewDistance); break;
@@ -1577,6 +1600,7 @@ static void CPE_Reset(void) {
 	cpe_needD3Fix = false; cpe_extEntityPos = false; cpe_twoWayPing = false; 
 	cpe_pluginMessages = false; cpe_extTextures = false; cpe_fastMap = false;
 	cpe_extBlocks = false; Game_UseCPEBlocks = false; cpe_blockPerms = false;
+	HACKEDCLIENT(Game_UseCPEBlocks = true);
 	if (!Game_UseCPE) return;
 
 	Net_Set(OPCODE_EXT_INFO, CPE_ExtInfo, 67);
